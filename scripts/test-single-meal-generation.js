#!/usr/bin/env node

/**
 * Test Single Meal Generation
 * Tests the meal generation script with one meal to verify schema compliance
 */

const { generateMealData } = require('./generate-meal-data.js');
const { createClient } = require('@supabase/supabase-js');
const dotenv = require('dotenv');
const path = require('path');

// Load environment variables
dotenv.config({ path: path.join(__dirname, '..', '.env.local') });

const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

// Expected database fields from schema check (excluding auto-generated fields)
const EXPECTED_FIELDS = [
  'allergens_present', 'cook_time', 'cooking_difficulty', 'cost_per_serving', 
  'courses', 'cuisines', 'description', 'diets_supported',
  'ingredient_tags', 'ingredients_json', 'instructions_json', 'prep_time', 
  'primary_ingredient', 'search_keywords', 'servings_default', 'servings_max', 
  'servings_min', 'slug', 'spice_level', 'time_total_min', 'title'
  // Note: id, image_url, created_at, updated_at are auto-generated by database
];

function validateMealSchema(mealData) {
  console.log('ğŸ” Validating generated meal against database schema...\n');
  
  const results = {
    valid: true,
    missingFields: [],
    extraFields: [],
    typeErrors: [],
    validationErrors: []
  };
  
  // Check for missing required fields
  EXPECTED_FIELDS.forEach(field => {
    if (!(field in mealData)) {
      results.missingFields.push(field);
      results.valid = false;
    }
  });
  
  // Check for extra fields (not critical, but good to know)
  Object.keys(mealData).forEach(field => {
    if (!EXPECTED_FIELDS.includes(field) && !['created_at', 'updated_at', 'id'].includes(field)) {
      results.extraFields.push(field);
    }
  });
  
  // Type and format validation
  const validations = [
    {
      field: 'slug',
      test: () => typeof mealData.slug === 'string' && /^[a-z0-9-]+$/.test(mealData.slug),
      message: 'slug must be lowercase alphanumeric with hyphens'
    },
    {
      field: 'title',
      test: () => typeof mealData.title === 'string' && mealData.title.length > 0,
      message: 'title must be a non-empty string'
    },
    {
      field: 'description',
      test: () => typeof mealData.description === 'string' && mealData.description.length > 0,
      message: 'description must be a non-empty string'
    },
    {
      field: 'courses',
      test: () => Array.isArray(mealData.courses) && 
                  mealData.courses.every(c => ['breakfast', 'lunch', 'dinner'].includes(c)),
      message: 'courses must be array of breakfast/lunch/dinner'
    },
    {
      field: 'cuisines',
      test: () => Array.isArray(mealData.cuisines) && mealData.cuisines.length > 0,
      message: 'cuisines must be non-empty array'
    },
    {
      field: 'diets_supported',
      test: () => Array.isArray(mealData.diets_supported),
      message: 'diets_supported must be an array'
    },
    {
      field: 'spice_level',
      test: () => Number.isInteger(mealData.spice_level) && mealData.spice_level >= 1 && mealData.spice_level <= 5,
      message: 'spice_level must be integer 1-5'
    },
    {
      field: 'prep_time',
      test: () => Number.isInteger(mealData.prep_time) && mealData.prep_time > 0,
      message: 'prep_time must be positive integer'
    },
    {
      field: 'cook_time',
      test: () => Number.isInteger(mealData.cook_time) && mealData.cook_time > 0,
      message: 'cook_time must be positive integer'
    },
    {
      field: 'time_total_min',
      test: () => Number.isInteger(mealData.time_total_min) && 
                  mealData.time_total_min === (mealData.prep_time + mealData.cook_time),
      message: 'time_total_min must equal prep_time + cook_time'
    },
    {
      field: 'cooking_difficulty',
      test: () => ['easy', 'medium', 'challenging'].includes(mealData.cooking_difficulty),
      message: 'cooking_difficulty must be easy/medium/challenging'
    },
    {
      field: 'servings_default',
      test: () => Number.isInteger(mealData.servings_default) && mealData.servings_default > 0,
      message: 'servings_default must be positive integer'
    },
    {
      field: 'servings_min',
      test: () => Number.isInteger(mealData.servings_min) && mealData.servings_min > 0,
      message: 'servings_min must be positive integer'
    },
    {
      field: 'servings_max',
      test: () => Number.isInteger(mealData.servings_max) && mealData.servings_max >= mealData.servings_default,
      message: 'servings_max must be >= servings_default'
    },
    {
      field: 'cost_per_serving',
      test: () => ['$', '$$', '$$$'].includes(mealData.cost_per_serving),
      message: 'cost_per_serving must be $, $$, or $$$'
    },
    {
      field: 'allergens_present',
      test: () => Array.isArray(mealData.allergens_present),
      message: 'allergens_present must be an array'
    },
    {
      field: 'search_keywords',
      test: () => Array.isArray(mealData.search_keywords) && mealData.search_keywords.length >= 5,
      message: 'search_keywords must be array with at least 5 items'
    },
    {
      field: 'ingredient_tags',
      test: () => Array.isArray(mealData.ingredient_tags) && mealData.ingredient_tags.length > 0,
      message: 'ingredient_tags must be non-empty array'
    },
    {
      field: 'ingredients_json',
      test: () => mealData.ingredients_json && 
                  typeof mealData.ingredients_json === 'object' &&
                  Array.isArray(mealData.ingredients_json.ingredients) &&
                  Number.isInteger(mealData.ingredients_json.servings),
      message: 'ingredients_json must have servings (int) and ingredients (array)'
    },
    {
      field: 'instructions_json',
      test: () => mealData.instructions_json && 
                  typeof mealData.instructions_json === 'object' &&
                  Array.isArray(mealData.instructions_json.steps),
      message: 'instructions_json must have steps array'
    }
  ];
  
  validations.forEach(validation => {
    if (mealData[validation.field] !== undefined) {
      try {
        if (!validation.test()) {
          results.validationErrors.push(`${validation.field}: ${validation.message}`);
          results.valid = false;
        }
      } catch (error) {
        results.typeErrors.push(`${validation.field}: ${error.message}`);
        results.valid = false;
      }
    }
  });
  
  // Detailed ingredients validation
  if (mealData.ingredients_json && mealData.ingredients_json.ingredients) {
    mealData.ingredients_json.ingredients.forEach((ingredient, index) => {
      const requiredFields = ['display_name', 'shoppable_name', 'quantity', 'unit', 'category', 'scale_type', 'optional'];
      const missingIngredientFields = requiredFields.filter(field => !(field in ingredient));
      
      if (missingIngredientFields.length > 0) {
        results.validationErrors.push(`Ingredient ${index + 1} missing fields: ${missingIngredientFields.join(', ')}`);
        results.valid = false;
      }
      
      if (ingredient.scale_type && !['linear', 'fixed', 'sqrt'].includes(ingredient.scale_type)) {
        results.validationErrors.push(`Ingredient ${index + 1} invalid scale_type: ${ingredient.scale_type}`);
        results.valid = false;
      }
    });
  }
  
  return results;
}

async function compareWithExistingMeal() {
  console.log('ğŸ“Š Fetching existing meal for comparison...\n');
  
  const { data: existingMeals, error } = await supabase
    .from('meals')
    .select('*')
    .limit(1);
    
  if (error || !existingMeals || existingMeals.length === 0) {
    console.log('âš ï¸  Could not fetch existing meal for comparison');
    return null;
  }
  
  const existing = existingMeals[0];
  console.log('ğŸ“‹ EXISTING MEAL REFERENCE:');
  console.log(`Title: ${existing.title}`);
  console.log(`Courses: ${existing.courses.join(', ')}`);
  console.log(`Cuisines: ${existing.cuisines.join(', ')}`);
  console.log(`Difficulty: ${existing.cooking_difficulty}`);
  console.log(`Timing: ${existing.prep_time}min prep + ${existing.cook_time}min cook = ${existing.time_total_min}min total`);
  console.log(`Servings: ${existing.servings_default} (${existing.servings_min}-${existing.servings_max})`);
  console.log(`Ingredients: ${existing.ingredients_json.ingredients.length} items`);
  console.log(`Instructions: ${existing.instructions_json.steps.length} steps`);
  
  return existing;
}

async function main() {
  console.log('ğŸ§ª Testing Single Meal Generation\n');
  
  // Test meal name
  const testMealName = 'Mediterranean Grilled Chicken with Lemon Rice';
  
  console.log(`ğŸ½ï¸  Generating: ${testMealName}\n`);
  
  try {
    // Generate meal data
    const generatedMeal = await generateMealData(testMealName);
    
    if (!generatedMeal) {
      console.log('âŒ Failed to generate meal data');
      return;
    }
    
    console.log('âœ… Meal data generated successfully!\n');
    
    // Show generated meal overview
    console.log('ğŸ“‹ GENERATED MEAL OVERVIEW:');
    console.log(`Title: ${generatedMeal.title}`);
    console.log(`Slug: ${generatedMeal.slug}`);
    console.log(`Courses: ${generatedMeal.courses?.join(', ') || 'N/A'}`);
    console.log(`Cuisines: ${generatedMeal.cuisines?.join(', ') || 'N/A'}`);
    console.log(`Difficulty: ${generatedMeal.cooking_difficulty}`);
    console.log(`Timing: ${generatedMeal.prep_time}min prep + ${generatedMeal.cook_time}min cook = ${generatedMeal.time_total_min}min total`);
    console.log(`Servings: ${generatedMeal.servings_default} (${generatedMeal.servings_min}-${generatedMeal.servings_max})`);
    console.log(`Cost: ${generatedMeal.cost_per_serving}`);
    console.log(`Spice Level: ${generatedMeal.spice_level}/5`);
    console.log(`Ingredients: ${generatedMeal.ingredients_json?.ingredients?.length || 0} items`);
    console.log(`Instructions: ${generatedMeal.instructions_json?.steps?.length || 0} steps`);
    console.log(`Keywords: ${generatedMeal.search_keywords?.length || 0} keywords\n`);
    
    // Validate against schema
    const validation = validateMealSchema(generatedMeal);
    
    console.log('ğŸ” SCHEMA VALIDATION RESULTS:');
    console.log(`Overall Valid: ${validation.valid ? 'âœ… PASS' : 'âŒ FAIL'}\n`);
    
    if (validation.missingFields.length > 0) {
      console.log('âŒ Missing Required Fields:');
      validation.missingFields.forEach(field => console.log(`  - ${field}`));
      console.log();
    }
    
    if (validation.extraFields.length > 0) {
      console.log('â„¹ï¸  Extra Fields (not in schema):');
      validation.extraFields.forEach(field => console.log(`  - ${field}`));
      console.log();
    }
    
    if (validation.validationErrors.length > 0) {
      console.log('âŒ Validation Errors:');
      validation.validationErrors.forEach(error => console.log(`  - ${error}`));
      console.log();
    }
    
    if (validation.typeErrors.length > 0) {
      console.log('âŒ Type Errors:');
      validation.typeErrors.forEach(error => console.log(`  - ${error}`));
      console.log();
    }
    
    // Compare with existing meal
    await compareWithExistingMeal();
    
    // Show sample ingredients
    if (generatedMeal.ingredients_json?.ingredients) {
      console.log('\nğŸ¥• SAMPLE INGREDIENTS (first 5):');
      generatedMeal.ingredients_json.ingredients.slice(0, 5).forEach((ing, i) => {
        console.log(`${i + 1}. ${ing.display_name}`);
        console.log(`   Shopping: ${ing.shoppable_name}`);
        console.log(`   Amount: ${ing.quantity} ${ing.unit}`);
        console.log(`   Category: ${ing.category} | Scale: ${ing.scale_type} | Optional: ${ing.optional}`);
      });
    }
    
    // Show sample instructions
    if (generatedMeal.instructions_json?.steps) {
      console.log('\nğŸ“ SAMPLE INSTRUCTIONS (first 3):');
      generatedMeal.instructions_json.steps.slice(0, 3).forEach(step => {
        console.log(`Step ${step.step}: ${step.instruction || step.text} (${step.time_minutes || 'no time specified'} min)`);
      });
    }
    
    console.log(`\n${validation.valid ? 'ğŸ‰ SUCCESS' : 'âš ï¸  ISSUES FOUND'}: Schema validation ${validation.valid ? 'passed' : 'failed'}`);
    
    if (validation.valid) {
      console.log('âœ… The generated meal matches the database schema perfectly!');
      console.log('âœ… All required fields are present and correctly formatted');
      console.log('âœ… Ready for database insertion');
    } else {
      console.log('âŒ The generated meal has schema issues that need to be fixed');
    }
    
  } catch (error) {
    console.error('ğŸ’¥ Test failed:', error.message);
    console.error(error.stack);
  }
}

// Run the test
if (require.main === module) {
  main().catch(console.error);
}

module.exports = { validateMealSchema };